"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendBtcTransaction = void 0;
const jsontokens_1 = require("jsontokens");
const provider_1 = require("../provider");
const serializer = (recipient) => {
    return recipient.map((value) => {
        const { address, amountSats } = value;
        return {
            address,
            amountSats: amountSats.toString(),
        };
    });
};
const sendBtcTransaction = async (options) => {
    const provider = await (0, provider_1.getProviderOrThrow)(options.getProvider);
    const { recipients, senderAddress, network, message } = options.payload;
    if (!recipients || recipients.length === 0) {
        throw new Error("At least one recipient is required");
    }
    if (recipients.some((item) => typeof item.address !== "string" || typeof item.amountSats !== "bigint")) {
        throw new Error("Incorrect recipient format");
    }
    if (!senderAddress) {
        throw new Error("The sender address is required");
    }
    try {
        const serializedRecipients = serializer(recipients);
        const serializedPayload = {
            network,
            senderAddress,
            message,
            recipients: serializedRecipients,
        };
        const request = (0, jsontokens_1.createUnsecuredToken)(serializedPayload);
        const response = await provider.sendBtcTransaction(request);
        options.onFinish?.(response);
    }
    catch (error) {
        console.error("[Connect] Error during send BTC transaction request", error);
        options.onCancel?.();
    }
};
exports.sendBtcTransaction = sendBtcTransaction;
//# sourceMappingURL=sendBtcTransaction.js.map